---
layout: Post
title: test
subtitle: test
author: a xi
date: 2022-10-14
useHeaderImage: true
headerImage: /images/home-bg/home-bg-2.jpg
headerMask: rgb(14, 21, 5, .2)
permalinkPattern: /post/:year/:month/:day/:slug/
tags:
  - test
---



### **软件测试流程**

1. 获取测试要求
2. 编写测试计划
3. 制定测试方案
4. 设计与开发测试用例
5. 执行测试
6. 提交缺陷报告 
7. 测试分析与评审
8. 提交测试总结
9. 准备下一版 本测试 

### 测试用例

1. 标识符（用例编号）：TextCase**_**项目名称**_**模块名称**_**功能名称_0001
2. 测试项：一句话表明测试目的
3. 依赖用例：例如 增加了一个数据的测试用例，将会被删除该数据的测试用例依赖，删除依赖增加。
4. 测试步骤：操作步骤，尽量详细，数据。
5. 测试数据：单独整合测试数据，和测试步骤中的数据保持一致
6. 预期结果：准备，原则上每一个操作，都要有一个结果。在重要的步骤之后，设定预期结果。 一般和测试目的密切相关。测试目的决定了测试步骤和预期结果
7. 测试结果：要求在测试执行完成后添加，没有执行保持为空；通过**/**失	败， **Pass / Failed**。
8. 测试人：可以和设计者一致。
9. 备注：为了测试用例正常执行而做的特殊准备。例如：专门用于网络不畅情况下，软件错误提示。

### **7**个用例设计方法

- 等价类划分法
- 边界值分析法
- 因果图法
- 判定表法
- 场景法
- 正交实验法
- 状态迁徙图法（功能图法）

### 缺陷概述

缺陷类型：功能、用户界面、文档、软件包、性能、接口。

缺陷严重程度：致命、严重、一般、较小。

缺陷修复优先级：立即解决**P1**级、高优先级**P2**级、正常排队**P3**级、低优先级**P4**级。

缺陷的状态：表示缺陷的处理进度

**①**：激活**/**打开**(**新建**)**：由测试人员标注

**②**：确认：确认新提交的是一个真实有效的缺陷，一般由测试主管或者质量保证**(QA)**、由产品经理进行确认；经确认后，有效的缺陷会指派给相关人员进行处理。

**③**：已修正**/**修复：在缺陷被修复后，一般由开发人员进行。

**④**：关闭**/**非激活：缺陷被修复完成后，经过测试人员验证后，没有问题。

**⑤**：重新打开：经过测试人员验证后，缺陷没有修复成功，需要重新打开进行再次处理和修复。

**⑥**：推迟：缺陷现在不修复，推迟到下一个版本或阶段，测试要跟开发或者其他相关管理人员进行确认。

**⑦**：保留：缺陷暂时修复不了。一般也是有开发人员去设定，也需要测试人员进行确认。

⑧：不能重现：开发按照缺陷显现步骤不能再次发现缺陷。一般闪退、崩溃类型的缺陷具有类似的特征，或者由于操作系统的差异、浏览器的缓存等出现的问题。所以作为测试人员，提交bug之前，要再三确认。

⑨：需要更多信息：作为测试人员，提交bug的时候，要尽可能的把所有相关的文件（图片、视频）一起提交。

⑩：重复：测试中，一定要避免这种情况的出现，尤其在一个软件的某一个功能频繁被多个模块（由不同的测试人员测试）调用的情况下。

⑪：不是缺陷：一定不要在测试工程师的工作生涯中被开发标注缺陷状态为不是bug。

⑫：需要修改需求说明书：缺陷不是技术原因造成的，而是由于需求不明确或者设计不明确造成。

### 缺陷的生命周期

发现缺陷

提交缺陷

确认缺陷：一般由测试主管或者质量保证QA、产品经理进行缺

分配缺陷：一般由谁确认的缺陷，就有谁分配，对象（开发、ui、产品）

修复缺陷

验证缺陷

关闭缺陷：只能是测试人员进行

### 缺陷的识别

依据：需求文档、设计文档、产品原型、测试用例，都是客观的依据。

同行业类似成熟软件、和开发人员沟通、跟有经验的测试人员沟通。

### 缺陷报告

1. 缺陷编号：BUG**_**项目名称**_**模块名称**_**功能名称**_**0001
2. 所属模块：一级模块/二级模块/三级模块
3. 优先级：缺陷的修复紧急程度，P1>P2>P3>P4
4. 严重程度：S1>S2>S3>S4
5. 缺陷概述：用一句话去描述缺陷的基本情况
6. 缺陷描述：将缺陷的复现步骤、预期结果和实际结果列出来
7. 提交人：是谁就写谁的名字
8. 备注：一般写产生该缺陷的特殊情况。将bug截图作为备注信息。

### 缺陷报告的编写目的

- 展现缺陷的详细信息
- 展现缺陷的影响程度和方式

读者很多，所以要写的直白、清晰、明了。

缺陷报告编写的准则：准确、清晰、一直、简洁、完整。

缺陷描述的规则：

- [ ] 可以再现
- [ ] 不做评价 

### 需求、用例、BUG的关系

获取测试需求是测试工作的重点，也是第一部，通过需求而的分析。了解和掌握测试的方向和内容。例如：

1）分析出系统的模块和组织结构

2）分析出软件的基本功能和运行流程（业务分析）包括可能会有哪些人或者哪些角色要用

3）识别出软件的重要功能和次要功能。

获取测试需求的过程中，测试人员就要有相应的分析成果。一般用xmind这样的思维导图工具进行分析，或者使用需求跟踪矩阵来完成测试需求的获取和分析。

设定测试中需求的正、反向和优先级。

当有了测试需求之后，就开始针对每一个需求点进行测试用力的设计。也就说，每一个需求点，都要被测试。

因此测试的过程中，衡量需求的覆盖程度就非常的重要。

**需求的覆盖程度 = 被测试用例覆盖的需求数 / 需求点总数** 

使用↑↑↑计算和说明。

如果需求覆盖度 < 100%，说明测试的覆盖度不够。

测试中，最能体现测试人员工作量的指标就是缺陷的数量和用例的数量

- 设计的测试用例总量   TC

- 执行的测试用例数量   EC

- 未执行的测试用例总量   WC

- 执行通过的测试用例总量   SC

- 执行失败的测试用例总量   FC

- 提交的缺陷的总量  BC（bug counts）

  ```javascript
  TC >= EC，
  
  TC = EC + WC，
  
  EC = SC + FC，
  
  BC >= FC，提交bug的数量，多于执行未通过的用例数。测试过程中发现的缺陷，一部分是用例执行失败带来的，还有一部分应该是测试人员自身的经验和直觉等带来的。
  通过 SC/EC 可以表现出系统的质量是否合格
  通过 EC/TC 可以表现出系统的需求是否得到满足
  ```

### Linux

### 数据库基础

数据Data

数据库Database

数据库管理系统DBMS

数据库系统DBS，DBS **=** 上边三者相加

 数据库系统的发展经历了3个阶段：

​		网状数据库、层次数据库、关系数据库

关键字：列，

属性名 = 字段名，

主键：唯一，不重复，不为空。

#### E+R图

实体-联系图，提供了标识实体类型、属性和联系的方法

通常用**矩形表示实体**型，矩形框内写明实体名

用**椭圆表示实体属性**，椭圆内写明实体属性名

用**菱形表示实体型间的联系**，在菱形内写明联系名

用线段连接起来

#### MySql


![image-20220930144852141](/images/typora-user-images/image-20220930144852141.png)

查看现有数据库： show databases;

创建数据库：create database 库名;

删除数据库：drop database 库名;

![image-20220930150904031](/images/typora-user-images/image-20220930150904031.png)

##### mySql数据类型：

1. 数值型：

- ​	整数类型：int

- ​	小数类型：decimal

- ​	小数格式：decimal(总长度，小数位)

  ​	decimal(5,2)：总长度5位，小数2位 → 123.45

  ​	价格decimal(3,2) → 9.99

2. 日期和时间类型

​	datetime：YYYY_MM_DD HH:MM:SS

​	date：YYYY+MM_DD

  3.字符串类型

​	char()：定长，不会释放空闲空间，系统会用空格填充满

​	varchar()：变长，剩下字符空间，会释放


<img src="/images/typora-user-images/image-20220930152320631.png" style="width:800px;height:480px" />

切换数据库：use 库名;

```mysql
创建表：create table 表名 (
​			列名2 数据类型,
​			列名3 数据类型,
​			列名4 数据类型,
​			);

create table student (
​	学号 varchar(15),
​	姓名 varchar(10),
​	性别 char(2),
​	年龄 int
);
```

删除表：drop table 表名;          多表之间有逗号

##### **修改表结果：**

​	添加列：alter table 表名add 属性名 数据类型;

​					alter table student 专业 varchar(7);

​	删除列：alter table 表名 drop 属性名;

​					alter table student  drop 专业;

​	修改字段的数据类型：alter table 表名 modify 字段名 新的数据类型;

​						alter table student modify 学号 int;

​	修改字段名：alter table 表名 change 旧字段名 新字段名 数据类型;

​						alter table student change 年龄 age int;

​	显示表：desc 表名;

​					desc student;

​	**<u>实体完整性约束：</u>**

​		**<u>目的：在表中至少有一个唯一的标识，主属性字段中，不能为空，不能重复。</u>**

##### 主键约束：		

主键约束：唯一，不重复，primary key，一个表中有且只有一个。

```mysql
********************关系型数据库通用，比如奥尔口，sqlserve。
格式一：create table 表名(
​						字段名1 数据类型 primary key,
​						字段名2 数据类型						
​						);
********************
格式二：主键约束名字的写法：PK_字段名
			create table 表名{
					字段名1 数据类型,
					字段名2 数据类型,
					主键约束的名字 primary key(字段名1)
					};
格式三： create table 表名{
					字段名1 数据类型,
					字段名2 数据类型,
					primary key(字段名1)
				}
针对已经存在的表，添加主键约束，三种格式：
​			alter table 表名 modify 字段名 数据类型 primary key;
​			alter table 表名 add primary key(字段名);
*************************
​			alter table 表名 add constraint 主键约束的名字 primary 				key(字段名);	
*************************
删除主键约束：
		alter table 表名 drop primary key;
```

<img src="/images/typora-user-images/image-20221008152344064.png" alt="image-20221008152344064" style="zoom: 77%;" />

联合主键：指的是把两个字段名看成是一个整体，这个整体不为空，唯一，不重复。

1.创建表的同时创建联合主键

```mysql
格式二：主键约束名字的写法：PK_字段名
			create table 表名{
					字段名1 数据类型,
					字段名2 数据类型,
					主键约束的名字 primary key(字段名1,字段名2)
					};
格式三： create table 表名{
					字段名1 数据类型,
					字段名2 数据类型,
					primary key(字段名1,字段名2)
				}
```

2.针对已经存在表，添加联合主键

```mysql
alter table 表名 add primary key(字段名1,字段名2);

alter table 表名 add constraint 主键约束的名字 primary 				key(字段名1,字段名2);
```

##### 唯一约束：

unique

特征：

1. 不允许有重复的值，保证数据的唯一性
2. 可以有空值
3. 在一个表中，可以有多个唯一约束
4. 默认情况下，唯一约束的名字和字段名保持一致
5. 添加唯一约束的列，系统也会默认给这个列添加一个唯一索引

索引：等同于书本的目录，将来能够加快数据的查询速度。

1.创建表的时候同时创建唯一约束

```mysql
格式一：
create table 表名(
	字段名1 数据类型,
  字段名2 数据类型,
  字段名3 数据类型,
  constraint 唯一约束的名字 unique(字段名1),
  constraint 唯一约束的名字 unique(字段名2)
);
格式二：
create table 表名(
	字段名1 数据类型 unique,
  字段名2 数据类型 unique,
  字段名3 数据类型
);

create table 会员表(
	会员编号 varchar(10),
  会员姓名 varchar(10),
  手机号 varchar(15),
  constraint UN_TEL unique(手机号)
);
```

一个表中可以存在多个约束。

2.针对已经存在的表，添加唯一约束

```mysql
alter table 表名 add unique(字段名1,字段名2);

alter table student add unique(学号);  
```

删除约束： alter table 表名 drop index 唯一约束的名字;

​					alter table 登记表 drop index 手机号;

​					alter table 会员表 drop index UN_TEL;

唯一约束名字默认和字段名一致。

<u>**域完整性约束：保证在表中不会输入无效的数据**</u>

##### 默认约束：

default

当默认约束来修饰某个列的时候，修饰的列即使不写数据也会默认一个值。

```mysql
1.创建表的时候同时创建默认约束
create table 表名{
	字段名1 数据类型 default '字符串类型或者日期类型的默认值',
	字段名2 数据类型 default 数值,
	字段名3 数据类型
};
create table 成绩表(
	学号 varchar(20) primary key,
  姓名 char(4),
  性别 char(2) default '男',
  成绩 int
);
2.针对已经存在的表，添加默认约束
alter table 表名 modify 列名 数据类型 default '值';

alter table 成绩表 modify 成绩 int default 60;

删除约束：
alter table 表名 modify 字段名 数据类型;
alter table 成绩表 modify 性别 char(2);
```

##### 非空约束：

not null，当前列必须有值

```mysql
1.在创建表的同时创建非空约束
create table 表名(
	字段名1 数据类型 not null,
  字段名2 数据类型 not null,
  字段名3 数据类型
);
create table tempstudent(
	sno varchar(10) primary key,
  sname char(10) unique,
  sdept varchar(20) not null,
  sage char(4) not null
);
2.针对已经存在的表，添加非空约束
alter table 表名 modify 列名 数据类型 not null;
alter table 成绩表 modify 姓名 char(4) not null;

删除非空约束
alter table 表名 modify 列名 数据类型;
```

**<u>参照完整性</u>**

##### 外键约束：

 foreign key

```mysql
1.创建表的时候同时创建外键约束
主表：
create table 表1{
		字段名1 数据类型 primary key,
		字段名2 数据类型
	};
从表(外键约束所在的表)：
create table 表名2(
   字段名1 数据类型,
   字段名2 数据类型
   constraint 外键约束的名字 foreign key(从表的字段名1) 	
   references 主表表名(字段名1)
  );
注意事项：
①：外键约束是建立在从表；
②：当从表的列参照主表的列，列名可以不一样，但是，这两个列的数据类型和内容必须保持一致；
③：从表引用主表的列，要求主表的列必须有主键约束或者唯一约束；
④：当主表的数据被从表引用，主表的数据无法删除；
⑤：当从表中的数据想做操作的时候，先询问主表的意见，主表有的，允许从表操作，主表没有，拒绝从表操作。

student表中学号参照引用tempstudent表中的sno
create table student(
	学号 varchar(10),
  姓名 varchar(10),
  年龄 int,
  constraint FK_SNO foreign key(学号) 
  references tempstudent(sno)
);

2.针对已经存在的表，添加外键约束
alter table 从表表名 add constraint 外键约束的名字 foreign key(从表列名1) references 主表表名(主表列名);

alter table 学生表 add constraint FK_SNO foreign key(学号) references 成绩表(sno);


删除外键约束
alter table 表名 drop foreign key 外键约束的名字;
alter table 学生表 drop foreign key FK_SNO;
```

##### 插入语句：

```mysql
************************
格式一：
insert into 表名(字段名1,字段名2,字段名3) values(,值1,值2,值3);

insert into student(学号,姓名,年龄,性别,专业) values(102,'tom',18,'男','会计');

格式二：
insert into student values(,值1,值2,值3);
************************

格式三：
insert into 表名 values(值1,值2,值3...),(值1,值2,值3...),(...);

insert into student values(102,'tom',18,'男','会计'),(103,'li',19,'女','财务');
```

##### 删除语句：

delete

```mysql
************************
delete from 表名;   把整个表中的数据全部删除。

delete仅限于删除表中数据，表还在，drop是把表和数据一并删除。

delete from 表名 where 条件;

delete from student where 专业='会计';
************************
```



##### 更新/修改语句：

```mysql
**********************

update 表名 set 列名=值;

update student set 专业='工商';

update 表名 set 列名1=值1,列名2=值2...;

update student set 年龄=18,性别='女';

update 表名 set 列名=值 where 条件;

update student set 专业='播音' where 性别='女';

************************

update student set 年龄=年龄+3;
update teacher set salary = 5000 where name='张三';
```

##### 查询语句：

```mysql
select 列名 from 表名;
select 列名1,列名2,列名3,列名4 from 表名;
去重：select distinct 列名 from 表名;
别名：select 列名1 '别名1',列名2 '别名2',列名3 '别名3' from student;
		 select 列名1 as '别名1',列名2 as 别名2 from 表名;

select 学号,姓名,性别 from student;
select distinct 专业 from student;
select 学号 'sid',年龄 'sage',性别 'sex' from student;
select 姓名 as 'name',性别 as 'sex' from student;
```

##### 计算列：

```mysql
select 学号,课程编号,成绩,成绩+10 '成绩' as from 成绩表;
```

##### 条件查询：

>  <=>操作符和 `=` 等于操作符类似，不过 `<=>` 可以用来判断 NULL 值，具体语法规则为：
>
> - 当两个操作数均为 NULL 时，其返回值为 1 而不为 NULL；
>
> - 而当一个操作数为 NULL 时，其返回值为 0 而不为 NULL。
>
>   ![image-20221010113833366](/images/typora-user-images/image-20221010113833366.png)

```mysql
 =  >  <  >=  <= <>  !=          !=等于<>

安全等于运算符：<=>
select * from 学生表 where 专业='播音' and 性别='女';
select * from student where 成绩<60;
```

范围搜索条件：

针对查询结果满足某个范围内的数据

select 列名 from 表名 where 列名 between 开始值 and 结束值;

select 列名 from 表名 where 列名 not between 开始值 and 结束值;

```mysql
查询成绩>=70,<=90
select 姓名,性别,年龄,成绩 from 成绩表 where 成绩 between 70 and 80;
```

列表搜索条件：**in**

通过in关键字使用户带上条件可以h和列表中任意值做匹配，满足其一就会有查询结果

select 列名 from 表名 where 列名 in(值1,值,值3...);

```mysql
select * from student where 籍贯 in('beijing','tianjin');
也可用or
select * from student where 籍贯='beijing' or 籍贯='shanghia';
```

**not in：**不在这个列表之内的

select 列名 from 表名 where 列名 not in(值1,值,值3...);

```mysql
select * from student where 籍贯 not in('beijing','tianjin');
```

字符匹配符：  **like  模糊查询**

通配符

| %    | 表示0个或多个字符 |
| ---- | ----------------- |
| _    | 表示一个字符      |

select 列名 from 表名 where 列名 like '字符模式';

```mysql
select * from student where name like '王%';
select * from student where name like '_大%';
```

not like

where not like '王%';

涉及空值的查询：

is null

is not null

```mysql
select 列名 from 表名 where 列名 is null;
select 列名 from 表名 where 列名 is not null;

select * from 成绩表 where 成绩 is null;
```

##### 聚合函数：

sum(列名)  对某个列求和

avg(列名)  对某个列求平均值

max(列名)  对某个列求最大值

min(列名)  对某个列求最小值

```mysql
select 聚合函数 from 表名;
select sum(成绩) '总成绩' from 成绩表;
select svg(成绩) '平均成绩' from 成绩表;
select max(成绩) '最高分',min(成绩) '最低分' from 成绩表;
```

count(*)  统计表中元组个数（一个表有多少条记录）

```mysql
select count(*) '总人数' from 成绩表;
select count(成绩) '成绩个数' from 成绩表;
除了count(*)外，替他函数再做操作时，均忽略空值(null);
```

##### 行数限定：

**limit**  哪行开始,查看几行数据

​		  [指定开始查询的行,]查询的总行数

> mysql数据库中行数是从0开始的

```mysql
select * from student limit 5;  前5行数据
select * from student limit 2,6;   第三行开始，查看6行数据
```

##### 数据分组：

**group by**

select 列名 聚合函数 from 表名 group by 列名;

```mysql
查询每个年级的总人数和班级数
某年级多少人几个班
select 年级,sum(人数) '总人数',count(*) '班级总数' from 班级表 group by 年级;
```

分组：1.先查询结果（先统计出相关的总数或总和）；

​			2.统计出来之后或查询出来后，再进行分组(依据某个列来进行分组)

##### 分组条件：

**having**  在分组中进行条件限制（对分组的结果添加条件）

select 列名 from 表名 group by 列名 having 条件;

一般情况下都是和聚合函数当做条件

**注意：**<u>having必须和group固定搭配</u>

​            <u>having后面可以写聚合函数，但是where后面不能写</u>

```mysql
查询成绩大于200的
select 学号,sum(成绩) from 成绩表 '总成绩' group by 学号 having '成绩'>200;
查询选课总数大于2门课的学生的学号
select 学号,count(课程) '选课总数' from 课程表 group by 学号 having count(课程)>=2;
```

##### 排序：

 **order by**

select 列名 from 表名 order by 列名 desc;

默认情况**升序asc**排列，**降序desc**

```mysql
select * from 成绩表 order by 成绩;      45 67 82 94
select * from 成绩表 order by 成绩 desc;  94 82 67 45

select 学号,成绩 from 成绩表 order by 成绩,学号 desc;
```

##### MySQL函数

**length(字符串)**  求的是字符串的字节长度

**char_length(字符串)**  求的是字符串的长度

```mysql
计算机系：4     工管系：3
select 系别,char_length(系别) '长度' from student;

计算机系：12    工管系：9    dd：2   hh：2
select 系别,length(系别) ‘字节总长度’ from student;

MySQL中一个汉字占3个字节，一个字母占1个字节
```

**mid(原始字符串,截取开始位置,截取长度)**

select mid(原始字符串,截取开始位置,截取长度) 别名 from student;

```mysql
select 系别,mid(系别,1,2) '截取后的字符串' from student;
```

**round(原始数据,保留小数位)**

> MySQL默认保留4位小数

> round如果不带参数，默认保留4位

```mysql
select round(34.5678,3);  34.568

select 学号,round(svg(成绩),2) '平均成绩' from 成绩表;
```

least(值1,值2,值3...)  求最小的数字

greatest(值1,值2,值3...) 求最大的数字

```mysql
select least(2,43,58,231,1);
select greatest(2,43,58,231,1);
```

**日期函数**

| now()             | 获取日期和时间     |
| ----------------- | ------------------ |
| current_date()    | 获取日期           |
| current_time()    | 获取时间           |
| to_days(日期值)   | 将日期转换成总天数 |
| dayofyear(日期值) | 求该年已过的天数   |
| week(日期值)      | 已过的周数         |

```mysql
select to_days(now());     从系统计时开始到今天的天数
select dayofyear(now());   今年已经过去了多少天
select week(now());        今年过去了多少周
```

**控制函数**

- if(布尔表达式,参数1,参数2)
- if(null,参数1,参数2)
- ifnull(参数1,参数2)
- ifnull(null,参数2)

```mysql
select if(5<6,'test','testing');
select ifnull(null),'testing';
```

##### 表连接：

1.内连接：提供了两种表与表之间的连接方式

1.1表连接的实现是通过where关键字来进行的关联

```mysql
表与表之间建立起关联的列，要求列名可以不一样，但是这两个列的数据类型和内容需保持一致。
select 表名1.列名1,表名1.列名2,表名2.列名1,表名2.列名2... 
from 表名1,表名2 
where 表名1.列名1=表名2.列名1;
```

**内连接查询 只关联表与表中 能够匹配到的数据**

```mysql
1.确定表 2.确定列 3.确定表与表之间能够关联的列 4.确定题上是否有额外要求
查询学生的学号、姓名、性别，以及所在的班级名称和年级
select 学生表.学号,学生表.姓名,学生表.性别,班级表.年级,班级表.班级名称
from 学生表,班级表
where 学生表.班级编号=班级表.班级编号;
```

------

```mysql
select 表名1.列名1,表名1.列名2,表名2.列名1,表名2.列名2... 
from 表名1 [inner] join 表名2
on 表名1.列名1=表名2.列名1;
```

```mysql
select xs.学号,xs.姓名,xs.性别,bj.年级,bj.班级编号 
from 学生表 xs inner join 班级表 bj
on 学生表.班级编号=班级表.班级编号;

select xs.学号,姓名,系别,kc.成绩
from 学生表 xs inner join 课程表 kc
on 学生表.学号=课程表.学号;

select xs.学号,xs.姓名,xs.性别,bj.年级,bj班级名称 
from 学生表 xs inner join 班级表 bj 
on 学生表.班级编号=班级表.班级编号 
where xs.籍贯='beijing' and bj.班级名称 like 'pu%';
```

inner join on 又划分为两个分类：

1.等值连接 指的是条件中质保函等号”=“，没有其它符号在里面

2.非等值连接 指的是条件中，除了等号之前，还有其他的符号 > < >=

```mysql
select xs.学号,姓名,班级编号,cj.成绩 
from 学生表 xs inner join 成绩表 cj 
on xs.学号=xs.学号 
where cj.成绩>40
order by cj.成绩 desc;
```

`select → from → where → group by → having → order by`

`select → from → inner join → on → where → group by → having → order by`

##### **多表查询**

1. select 表名.列名 from 表名1,表名2,表名3 where 表名1.列名=表名2.列名 and 表名2.列名=表名3.列名;
2. select from 表名1 inner join 表名2 on 表名1.列名=表名2.列名 inner join 表名3 on 表名2.列名=表名3,列名;![image-20221011181630037](/images/typora-user-images/image-20221011181630037.png)

![image-20221012115818765](/images/typora-user-images/image-20221012115818765.png)

**外连接 至少会返回出一个表的所有内容**

左外连接：对左边的表不加限制，返回左表的所有行

右外连接：对右边的表不加限制，返回右表的所有行

在from之后，先写的表是左表，后写的表是右表

```mysql
select 表名.列名 
from 表名1 left outer join 表名2
on 表名1.列=表名2.列;

会返回左表的所有内容，如果在右表中没有匹配到，在对应位置上就显示为null

select xs.学号,姓名,课程编号,成绩
from 学生表 xs left outer join 成绩表 cj
on xs.学号=cj.学号;

右外连接同理。
```

##### 子查询：

指的是查询语句里面嵌套查询语句

**select 列名 from 表名 where 列名 in(查询语句);**

```mysql
select 列名 from 表名 where 列名 in(select 列名 from 表名 where 列名 in(select 列名 from 表名 where 条件));
```

注意事项：

1. where后面条件要什么，子查询就查什么，例：条件要学号，子查询就查学号
2. 优先考虑子查询的情况：题中没有给出明确的提示结果，
3. where后面要用到举个函数当条件

```mysql
例：查询计算机系学生选择了哪些课程？问：计算机系学生有哪些？
聚合函数不能直接写，可以借助查询语句把聚合函数的结果查出来
成绩大于平均成绩
where grade>(select avg(grade) from 成绩表);

select distinct 学号 from 课程表  
where 学号 in(select 学号 from 学生表 where 系别='计算机系');

查询修了”c02“课程且成绩高于此课程的平均成绩的学生的学号和成绩
select 学号,成绩
from 成绩表
where 课程='c02' and 成绩>(select avg(成绩) from 成绩表 where 课程='c02');

```

嵌套子查询：指的是子查询中还包含其他的子查询

相关子查询：指的是子查询的结果有且只有一个值



当insert语句和select语句做结合，就是把查询的结果插入到某一张表中

格式：insert into 表名 select 查询语句

向学生信息表插入籍贯是北京的数据

```mysql
insert into 学生信息表 select * from 学生信息 where 籍贯='北京';

insert into stu select 学号,姓名,系别 from student;

insert into 成绩表 select * from 成绩表 where 成绩>70 and 课程编号='1003';
```

更新语句

update 表名 set 值 where 列名 in(select查询语句)

```mysql
update 学生表 set 成绩=成绩+5 where 学号 in(select 成绩 from 学生表 where 系别='计算机系');
```

删除语句

delete from 表名 where 列名 in(select 查询语句)

```mysql
例：删除计算机系学生的成绩
delete from 学生表 where 学号 in(select 学号 from student where 系别='计算机系');
```

##### 视图

指的是根据某个实际的表（实表）查询出来，生成的一个虚表

目的是方便用户的操作

**创建视图**

create view 视图名字 as select 语句

```mysql
create view view_班级信息 as select * from 班级信息;
select * from view_班级信息;
update view_班级信息 set 人数=100 where 年级='er';
insert into view_班级信息 values(‘15’,'jiayou','yi',40);
```

注意事项：视图既然作为一张虚标存在，那么对实表的增删改查操作，视图同样成立。

视图既然是根据实表得到的，那么对视图的增删改查操作，同样影响实表。

向视图中插入数据的时候，注意约束的影响。

**修改视图**

alter view 视图名 as select 语句;

```mysql
alter view_班级信息 as select * from 班级信息;
update view_班级信息 set 班级编号=20 where 人数=100;
```

**插入数据**

insert into 视图名 values(值1,值2...);

```mysql
insert into view_班级信息 values(‘15’,'jiayou','yi',40);
```

**删除视图**

带有条件删除视图中的数据

```mysql
delete from view_班级信息2 where 班级编号=28;
```

删除视图：drop view 视图名;

```mysql
drop view view_班级信息2;
```

删除两个视图：drop view 视图1,视图2;

> drop删除，不影响原表

##### 索引：

指的是在数据库表中的一个列或多个列的设置，帮助快速的定位所查询的数据。

作用（优点）：

- 加快查询速度（定位）
- 保证数据的唯一性（唯一约束）
- 实现表与表之间的参照完整性（进行外键约束参照的列）
- 可以减少group by、order by，分组和排序的时间（根据某个列来进行分组或排序）

索引的弊端：

（1）索引本身很大，可以存放在内存或硬盘上，通常存储在硬盘上。

（2）索引不是所有情况都使用，比如①少量数据②频繁变化的字段③很少使用的字段

（3）索引会降低增删改的效率

------

**索引的分类**

| 按数据结构分类： | B+tree索引、[Hash](https://so.csdn.net/so/search?q=Hash&spm=1001.2101.3001.7020)索引、Full-text索引 |
| ---------------- | :----------------------------------------------------------- |
| 按物理存储分类： | 聚集索引、非聚集索引（也叫二级索引、辅助索引）               |
| 按字段特性分类： | 主键索引(PRIMARY KEY)、唯一索引(UNIQUE)、普通索引(INDEX)、全文索引(FULLTEXT)。 |
| 按字段个数分类： | 单列索引、[联合索引](https://so.csdn.net/so/search?q=联合索引&spm=1001.2101.3001.7020)（也叫复合索引、组合索引） |

​	普通索引：alter table 表名 add index index_name(''列名'');

> FULLTEXT(全文索引)
>
> alter table 表名 add fulltext ('列名');
>
> 仅可用于MyISAM表，针对较大的数据，生成全文索引很耗时和耗空间

（1）**单值（列）索引**：以某一个字段为索引

```mysql
create table User(
`name` varchar(50) not null,
`uid` int(4) not null,
`gender` int(2) not null,
 key(`name`)
);
```

（2）**唯一索引**：主要用于业务上的唯一约束，他跟主键索引的区别是，一个表可以有多个唯一索引。

```mysql
create table User(
`name` varchar(50) not null,
`uid` int(4) not null,
`gender` int(2) not null,
 unique key(`name`)
);

alter table 表名 add unique('列名');
```

（3）**联合(多列、组合)索引**：两个或两个以上字段联合组成一个索引。使用时需要注意满足最左匹配原则

​		最左前缀原则指的是，查询从联合索引的最左列开始，并且不跳过索引中的列。如下：select * from user where name=xx and city=xx ;

```mysql
create table User(
`name` varchar(50) not null,
`uid` int(4) not null,
`gender` int(2) not null,
 key(`name`,`uid`)
);

alter table 表名 add index index_name('列名1','列名2','列名3');
```

（4）**主键索引**：主键索引是唯一的，通常以表的ID设置为主键索引，一个表只能有一个主键索引，这是它与唯一索引的区别。

```mysql
create table User(
`name` varchar(50) not null,
`uid` int(4) not null,
`gender` int(2) not null,
 primary key(`uid`)
);

alter table 表名 add primary key('列名');
```

备注：唯一索引和主键索引唯一的区别：主键索引不能为null

**查看索引**：show index from 表名;

**删除索引**：drop index [index_name] on 表名;

数据库只会选择一个最优的索引来使用，并不会使用全部索引。

```
索引失效的情况：

1、like查询以“%”开头，如‘%XXX’；
2、or语句前后没有同时使用索引；
3、组合索引中不是使用第一列索引；
4、在索引字段上使用“not”，“<>”，“!=”等等。

补充：有类型转换时索引失效；
		 where中索引列使用了函数和运算；
		 is null可以走索引，is not null无法使用索引；
		 字符串不加单引号索引会失效；复合(联合)索引没有用到左列字段；
		 
		 OR前后存在非索引的列，索引失效
     如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)
     要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引
```

------

简洁版：

mysql有哪些索引

- index 普通索引
  - alter table `table_name` add index index_name(`column`)
  - 最基本的索引，没有任何限制
- primary key 主键索引
  - alter table `table_name` add primary key(`column`)
  - 是一种特殊的唯一索引，不允许有空值
- unique 唯一索引
  - alter table `table_name` add unique(`column`)
  - 与“普通索引”类似，不同的就是，索引列的值必须是唯一，但允许有空值
- filltext 全文索引
  - alter table `table_name` add fulltext(`column`)
  - 仅可用于MyISAM表，针对较大的数据，生成全文索引很耗时和耗空间
- 组合索引
  - alter table `table_name` add index index_name(`column1`,`column2`,`column3`)
  - 遵循“最左前缀”原则

```mysql
创建索引
create index index_name on table_name(column_name)
修改表结构（添加索引）
alter table table_name add index index_name(column_name)
创建表时直接指定
create table table_name(
  id int not null,
  username varchar(64) not null,
  index [index_name] (username)  
);
删除索引
drop index [index_name] on table_name
```

------

##### 数据库管理系统（DBMS）：

管理数据库，位于应用程序和数据库之间的一个管理软件

四大功能：定义、操作、维护、保护功能。

实体联系模型

实体：对客观事物的反映

属性：用来修饰实体

联系：一对一、一对多、多对多

例：学生，拥有学号、成绩、专业

实体集：实体的集合，具有相同属性的实体

##### Oracle

数据库实例=表+数据

数据库（图书馆）实例（书籍）

数据库实例关闭（图书馆闭馆）

数据库实例开启（图书馆开放）



数据库实例的开启：启动实例，加载数据库，打开数据库

startup

nomount 开启实例

mount 开启实例，加载数据库，但是数据库还是一个关闭的状态

<u>open 启动，加载，打开</u>

force 强制终止实例并重启数据库实例



普通用户切换：conn 用户名/密码;

sys用户切换： conn 用户名/密码 as sysdba;



显示当前用户：show user;

关闭数据库实例： 

```mysql
	1、shutdown normal
　　正常方式关闭数据库。等待用户完成工作然后关闭；
​	2、shutdown immediate
		立即关闭 ,当前所有做工作回滚到一致状态,断开其连接；
　　立即方式关闭数据库。
　　在SVRMGRL中执行shutdown immediate，数据库并不立即关闭，
　　而是在Oracle执行某些清除工作后才关闭（终止会话、释放会话资源），
　　当使用shutdown不能关闭数据库时，shutdown immediate可以完成数据库关闭的操作。 　　
​​​	3、shutdown abort
		强制关闭,非干净关闭,下次重起后要回滚日志；
		直接关闭数据库，正在访问数据库的会话会被突然终止，
		如果数据库中有大量操作正在执行，这时执行shutdown abort后，重新启动数据库需要很长时间。
​	4、Shutdown transactional 
		等待用户完成工作但是强制关闭连接；
```

数据库实例的启动与关闭，只有sys用户才有权限

oracle数据库的查询：

select 列名 | *  from 表名;

查询所有的表名：select * from tab;

未选定行 代表的是没有查询的结果

设置一行显示的字符总数

set linesize 长度;

设置每页显示多少行

set pagesize 行;

查看表结构： desc 表名;

oracle数据类型：

字符串类型：varchar2(长度)  等同于varchar(长度)

数值型： number或者number(长度) 整数

​				number(总位数,小数位)  小数

日期：date

------

连接符：||

把字符串和表中查询的数据来做一个拼接

```mysql
例子： 要求查询出雇员的编号，姓名，工作，按照以下格式显示：
			编号是:7369的雇员.姓名是:SMITH.工作是:CLERK
			
			select '编号是:' || empno || '的雇员.姓名是:' || ename '.工作' || job from emp;

```















##### 相关配套单词

|    英语     |    汉语    |
| :---------: | :--------: |
|    tail     |    尾巴    |
|   change    |    改变    |
|    alter    |    改变    |
|    drop     |    下降    |
|   modify    |    修改    |
|   unique    |   独特的   |
| primary key |    主键    |
| constraint  |    约束    |
|    dept     |    部门    |
| foreign key |    外键    |
|  distinct   | 截然不同的 |
|  group by   |    集团    |
|    grade    |    年级    |
|   article   |    文章    |
|    join     |    加入    |
|    outer    |     外     |
|    inner    |   内心的   |
|             |            |
|             |            |
|             |            |
|             |            |
|             |            |
|             |            |
|             |            |
|             |            |
